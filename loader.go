package marker

import (
	"errors"
	"fmt"
	"go/token"
	"golang.org/x/tools/go/packages"
	"os/exec"
	"strings"
	"sync"
)

type Package struct {
	*packages.Package
	loader            *loader
	isStandardPackage bool
}

// newPackage returns a wrapped Package for the given packages.Package,
func newPackage(pkg *packages.Package, loader *loader) *Package {
	return &Package{
		Package: pkg,
		loader:  loader,
	}
}

func (pkg *Package) IsStandardPackage() bool {
	return pkg.isStandardPackage
}

// loader loads Go packages and their imports.
type loader struct {
	config       *packages.Config
	patterns     []string
	packages     []*Package
	packageMap   map[*packages.Package]*Package
	packageMapMu sync.Mutex
}

// newLoader returns a new loader to load the Go packages by the given
// configuration and patterns.
func newLoader(config *packages.Config, patterns ...string) *loader {
	return &loader{
		config:     config,
		patterns:   patterns,
		packages:   make([]*Package, 0),
		packageMap: make(map[*packages.Package]*Package),
	}
}

// load loads and returns the Go packages.
//
// load returns an error if any of the patterns was invalid.
func (loader *loader) load() ([]*Package, error) {
	pkgs, err := packages.Load(loader.config, loader.patterns...)

	if err != nil {
		return nil, err
	}

	for _, pkg := range pkgs {

		if loader.packageMap[pkg] == nil {
			loader.packageMap[pkg] = newPackage(pkg, loader)
			pkg.Fset = loader.config.Fset
		}

		//putPackageToCache(pkg.ID, loader.packageMap[pkg])
		loader.packages = append(loader.packages, loader.packageMap[pkg])

	}

	return loader.packages, nil
}

type LoadResult struct {
	packages         map[string]*Package
	standardPackages map[string]*Package
}

func (result *LoadResult) GetPackages() []*Package {
	pkgs := make([]*Package, 0)

	for _, pkg := range result.packages {
		pkgs = append(pkgs, pkg)
	}

	return pkgs
}

func (result *LoadResult) Lookup(pkgPath string) (*Package, error) {
	pkg, ok := result.standardPackages[pkgPath]

	if !ok {
		pkg, ok = result.packages[pkgPath]
	} else {
		return pkg, nil
	}

	if !ok {
		return nil, fmt.Errorf("package with id %s not found", pkgPath)
	}

	return pkg, nil
}

func (result *LoadResult) GetStandardPackages() []*Package {
	pkgs := make([]*Package, 0)

	for _, pkg := range result.standardPackages {
		pkgs = append(pkgs, pkg)
	}

	return pkgs
}

// LoadPackages loads and returns the Go packages by the given patterns.
func LoadPackages(patterns ...string) (*LoadResult, error) {
	return LoadPackagesWithConfig(&packages.Config{}, patterns...)
}

// LoadPackagesWithConfig functions like LoadPackages.
// Except that it allows passing a custom config.
func LoadPackagesWithConfig(config *packages.Config, patterns ...string) (*LoadResult, error) {

	if config == nil {
		return nil, errors.New("config must not be nil")
	}

	config.BuildFlags = append([]string{"-tags", "ignore_autogenerated"}, config.BuildFlags...)
	config.Mode |= packages.NeedName | packages.NeedFiles | packages.NeedCompiledGoFiles |
		packages.NeedImports | packages.NeedSyntax | packages.NeedModule |
		packages.NeedTypesInfo | packages.NeedTypes

	if config.Fset == nil {
		config.Fset = token.NewFileSet()
	}

	packagePatterns := append([]string{}, patterns...)

	pkgs, err := newLoader(config, packagePatterns...).load()

	if err != nil {
		return nil, err
	}

	// get standard package list
	cmd := exec.Command("go", "list", "std")

	var stdPackageListOutput []byte
	stdPackageListOutput, err = cmd.Output()

	if err != nil {
		return nil, errors.New("std packages could not be loaded")
	}

	standardPackages := make(map[string]struct{})
	standardPackageList := strings.Fields(string(stdPackageListOutput))

	for _, standardPackage := range standardPackageList {
		standardPackages[standardPackage] = struct{}{}
	}

	loadResult := &LoadResult{
		packages:         make(map[string]*Package),
		standardPackages: make(map[string]*Package),
	}

	for _, pkg := range pkgs {
		if _, ok := standardPackages[pkg.ID]; ok || pkg.ID == "builtin" {
			pkg.isStandardPackage = true
			loadResult.standardPackages[pkg.ID] = pkg
		} else {
			loadResult.packages[pkg.ID] = pkg
		}
	}

	return loadResult, nil
}
