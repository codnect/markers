package marker

import (
	"errors"
	"go/token"
	"golang.org/x/tools/go/packages"
	"sync"
)

type Package struct {
	*packages.Package
	loader *loader
}

func newPackage(pkg *packages.Package, loader *loader) *Package {
	return &Package{
		Package: pkg,
		loader:  loader,
	}
}

type loader struct {
	config       *packages.Config
	patterns     []string
	packages     []*Package
	packageMap   map[*packages.Package]*Package
	packageMapMu sync.Mutex
}

func newLoader(config *packages.Config, patterns ...string) *loader {
	return &loader{
		config:     config,
		patterns:   patterns,
		packages:   make([]*Package, 0),
		packageMap: make(map[*packages.Package]*Package),
	}
}

func (loader *loader) load() ([]*Package, error) {
	pkgs, err := packages.Load(loader.config, loader.patterns...)

	if err != nil {
		return nil, err
	}

	for _, pkg := range pkgs {

		if loader.packageMap[pkg] == nil {
			loader.packageMap[pkg] = newPackage(pkg, loader)
			pkg.Fset = loader.config.Fset
		}

		loader.packages = append(loader.packages, loader.packageMap[pkg])

	}

	return loader.packages, nil
}

func LoadPackages(patterns ...string) ([]*Package, error) {
	return LoadPackagesWithConfig(&packages.Config{}, patterns...)
}

func LoadPackagesWithConfig(config *packages.Config, patterns ...string) ([]*Package, error) {

	if config == nil {
		return nil, errors.New("config must not be nil")
	}

	config.BuildFlags = append([]string{"-tags", "ignore_autogenerated"}, config.BuildFlags...)
	config.Mode |= packages.NeedName | packages.NeedFiles | packages.NeedCompiledGoFiles | packages.NeedImports | packages.NeedSyntax | packages.NeedModule

	if config.Fset == nil {
		config.Fset = token.NewFileSet()
	}

	return newLoader(config, patterns...).load()
}
