package marker

import (
	"errors"
	"go/token"
	"golang.org/x/tools/go/packages"
	"sync"
)

type Package struct {
	*packages.Package
	loader *loader
}

// newPackage returns a wrapped Package for the given packages.Package,
func newPackage(pkg *packages.Package, loader *loader) *Package {
	return &Package{
		Package: pkg,
		loader:  loader,
	}
}

func (pkg *Package) Compare(another *Package) bool {
	if another == nil {
		return false
	}

	if pkg == another || pkg.ID == another.ID {
		return true
	}

	return false
}

// loader loads Go packages and their imports.
type loader struct {
	config       *packages.Config
	patterns     []string
	packages     []*Package
	packageMap   map[*packages.Package]*Package
	packageMapMu sync.Mutex
}

// newLoader returns a new loader to load the Go packages by the given
// configuration and patterns.
func newLoader(config *packages.Config, patterns ...string) *loader {
	return &loader{
		config:     config,
		patterns:   patterns,
		packages:   make([]*Package, 0),
		packageMap: make(map[*packages.Package]*Package),
	}
}

// load loads and returns the Go packages.
//
// load returns an error if any of the patterns was invalid.
func (loader *loader) load() ([]*Package, error) {
	pkgs, err := packages.Load(loader.config, loader.patterns...)

	if err != nil {
		return nil, err
	}

	for _, pkg := range pkgs {

		if loader.packageMap[pkg] == nil {
			loader.packageMap[pkg] = newPackage(pkg, loader)
			pkg.Fset = loader.config.Fset
		}

		loader.packages = append(loader.packages, loader.packageMap[pkg])

	}

	return loader.packages, nil
}

// LoadPackages loads and returns the Go packages by the given patterns.
func LoadPackages(patterns ...string) ([]*Package, error) {
	return LoadPackagesWithConfig(&packages.Config{}, patterns...)
}

// LoadPackagesWithConfig functions like LoadPackages.
// Except that it allows passing a custom config.
func LoadPackagesWithConfig(config *packages.Config, patterns ...string) ([]*Package, error) {

	if config == nil {
		return nil, errors.New("config must not be nil")
	}

	config.BuildFlags = append([]string{"-tags", "ignore_autogenerated"}, config.BuildFlags...)
	config.Mode |= packages.NeedName | packages.NeedFiles | packages.NeedCompiledGoFiles |
		packages.NeedImports | packages.NeedSyntax | packages.NeedModule |
		packages.NeedTypesInfo | packages.NeedTypes

	if config.Fset == nil {
		config.Fset = token.NewFileSet()
	}

	return newLoader(config, patterns...).load()
}
