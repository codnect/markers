package marker

import (
	"errors"
	"go/ast"
	"go/parser"
	"go/scanner"
	"go/token"
	"go/types"
	"golang.org/x/tools/go/packages"
	"io/ioutil"
	"os"
	"sync"
)

type Package struct {
	*packages.Package
	loader *loader
}

func newPackage(pkg *packages.Package, loader *loader) *Package {
	return &Package{
		Package: pkg,
		loader:  loader,
	}
}

func (pkg *Package) prepare() {

	if pkg.Syntax != nil {
		return
	}

	out := make([]*ast.File, len(pkg.CompiledGoFiles))

	var wg sync.WaitGroup
	wg.Add(len(pkg.CompiledGoFiles))

	for index, fileName := range pkg.CompiledGoFiles {

		go func(index int, fileName string) {
			defer wg.Done()

			src, err := ioutil.ReadFile(fileName)

			if err != nil {
				pkg.addError(err)
				return
			}

			out[index], err = pkg.loader.parseFile(fileName, src)

			if err != nil {
				pkg.addError(err)
				return
			}
		}(index, fileName)

	}

	wg.Wait()

	for _, file := range out {
		if file == nil {
			return
		}
	}

	pkg.Syntax = out
}

func (pkg *Package) addError(err error) {

	switch typedErr := err.(type) {
	case *os.PathError:
		pkg.Errors = append(pkg.Errors, packages.Error{
			Pos:  typedErr.Path + ":1",
			Msg:  typedErr.Err.Error(),
			Kind: packages.ParseError,
		})
	case scanner.ErrorList:
		for _, subErr := range typedErr {
			pkg.Errors = append(pkg.Errors, packages.Error{
				Pos:  subErr.Pos.String(),
				Msg:  subErr.Msg,
				Kind: packages.ParseError,
			})
		}
	case types.Error:
		pkg.Errors = append(pkg.Errors, packages.Error{
			Pos:  typedErr.Fset.Position(typedErr.Pos).String(),
			Msg:  typedErr.Msg,
			Kind: packages.TypeError,
		})
	default:
		pkg.Errors = append(pkg.Errors, packages.Error{
			Pos:  pkg.ID + ":-",
			Msg:  err.Error(),
			Kind: packages.UnknownError,
		})
	}

}

type loader struct {
	config       *packages.Config
	patterns     []string
	packages     []*Package
	packageMap   map[*packages.Package]*Package
	packageMapMu sync.Mutex
}

func newLoader(config *packages.Config, patterns ...string) *loader {
	return &loader{
		config:     config,
		patterns:   patterns,
		packages:   make([]*Package, 0),
		packageMap: make(map[*packages.Package]*Package),
	}
}

func (loader *loader) load() ([]*Package, error) {
	pkgs, err := packages.Load(loader.config, loader.patterns...)

	if err != nil {
		return nil, err
	}

	for _, pkg := range pkgs {

		if loader.packageMap[pkg] == nil {
			newPkg := newPackage(pkg, loader)
			newPkg.prepare()

			loader.packageMap[pkg] = newPkg
		}

		loader.packages = append(loader.packages, loader.packageMap[pkg])

	}

	return loader.packages, nil
}

func (loader *loader) parseFile(fileName string, src []byte) (*ast.File, error) {
	file, err := parser.ParseFile(loader.config.Fset, fileName, src, parser.AllErrors|parser.ParseComments)

	if err != nil {
		return nil, err
	}

	return file, nil
}

func LoadPackages(patterns ...string) ([]*Package, error) {
	return LoadPackagesWithConfig(&packages.Config{}, patterns...)
}

func LoadPackagesWithConfig(config *packages.Config, patterns ...string) ([]*Package, error) {

	if config == nil {
		return nil, errors.New("config must not be nil")
	}

	config.BuildFlags = append([]string{"-tags", "ignore_autogenerated"}, config.BuildFlags...)
	config.Mode |= packages.NeedName | packages.NeedFiles | packages.NeedCompiledGoFiles | packages.NeedImports

	if config.Fset == nil {
		config.Fset = token.NewFileSet()
	}

	return newLoader(config, patterns...).load()
}
